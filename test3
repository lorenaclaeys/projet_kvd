
from scipy import fft,ifft
def Kdvanalytic(x,t,c,a):
    u = (c/2.)*np.cosh((math.sqrt(c)/2.)*(x - c*t - a))**(-2)
    return u

def inverse(t,L,k):
    u = Kdvanalytic(x,t,c,a)
    u_hat = fft(u)
    for dt in range(t):
        b = 2*mat.pi/L/k
        g_hat = exp(-i*dt*(b)**3)*u_hat(x,t,c,a)
        g = real(ifft(g_hat))
        g_hat2 = fft(g**2)
        g2= real(ifft(i*b*g_hat2))
    return g, g2,

# constants
L = 50.      # period
Nx = 256     # space step
x = np.linspace(0,L,Nx)

# parametres temporels
tmax = 200
t0 = 0
Nt = 501 #timestep
t = np.linspace(t0,tmax,Nt)

# parameters for the initial condition
c1 = 0.75
c2 = 0.4
a1 = 0.33
a2 = 0.65

k = np.zeros(Nx)


u0_hat = fft( Kdvanalytic(x,t0,c1,a1*L) + Kdvanalytic(x,t0,c2,a2*L))
g, g2 = inverse(t,L,k)

def euler_forward(g,g2,Nx):
    data_u = np.zeros(tmax)
    for dt in range(t):
        data_u[dt] = g - 3*g2*dt
    return data_u

#graph
plt.figure(figsize=(6,5))
plt.imshow(data_u[::-1, :], extent=[0,L,0,tmax])
plt.colorbar()
plt.xlabel('x')
plt.ylabel('t')
plt.axis('auto')
plt.title('Korteweg-de Vries -two solutions')
plt.show()    
